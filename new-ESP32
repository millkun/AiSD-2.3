#include <Arduino.h>
#include <WiFi.h>
#include <HTTPClient.h>
#include <driver/adc.h>
#include "ArduinoJson.h"
#include "GyverMAX7219.h"

// Конфигурация сети
const char* ssid = "millkun";
const char* password = "assembler";
const char* serverUrl = "http://192.168.25.116:5000/process_audio";
const unsigned long apiTimeout = 5000;

// Настройки аудио
#define SAMPLE_RATE 16000
#define RECORD_DURATION_MS 1500 // Записываю 1.5 секунды
#define BUFFER_SIZE (SAMPLE_RATE * RECORD_DURATION_MS / 1000) // 24000 сэмплов
#define CHUNK_SIZE 2048 // Размер одного чанка для отправки

// Настройки матрицы
#define MATRIX_CS_PIN 27
#define MATRIX_DIN_PIN 13
#define MATRIX_CLK_PIN 14
#define MATRIX_NUM 1

// Настройки кнопки
#define BUTTON_PIN 27
#define DEBOUNCE_DELAY 50

MAX7219<MATRIX_NUM, MATRIX_NUM, MATRIX_CS_PIN, MATRIX_DIN_PIN, MATRIX_CLK_PIN> matrix;

// Глобальные переменные
int16_t audioBuffer[BUFFER_SIZE];
WiFiClient client;
volatile bool buttonPressed = false;
volatile bool isRecording = false;
volatile bool isProcessing = false;
unsigned long recordStartTime = 0;

// Прототипы функций
void IRAM_ATTR buttonISR();
void connectWiFi();
String prepareAudioChunkJson(int startIndex, int count);
bool sendAudioToServer();
void handleCommand(String command);

void IRAM_ATTR buttonISR() {
    static unsigned long lastInterruptTime = 0;
    unsigned long interruptTime = millis();
    
    if (interruptTime - lastInterruptTime > DEBOUNCE_DELAY && !isRecording && !isProcessing) {
        buttonPressed = true;
    }
    lastInterruptTime = interruptTime;
}

void connectWiFi() {
    if (WiFi.status() == WL_CONNECTED) return;
    
    Serial.println("Подключение к WiFi...");
    WiFi.begin(ssid, password);
    WiFi.setAutoReconnect(true);
    WiFi.persistent(true);
    
    unsigned long startTime = millis();
    while (WiFi.status() != WL_CONNECTED && millis() - startTime < 15000) {
        delay(500);
        Serial.print(".");
    }
    
    if (WiFi.status() != WL_CONNECTED) {
        Serial.println("\nОшибка подключения к WiFi!");
    } else {
        Serial.println("\nПодключено к WiFi!");
        Serial.print("IP адрес: ");
        Serial.println(WiFi.localIP());
    }
}

void recordAudio() {
    Serial.println("Начало записи...");
    isRecording = true;
    matrix.clear();
    matrix.dot(0, 1, 1); // Индикатор записи
    matrix.update();
    
    unsigned long startTime = millis();
    for (int i = 0; i < BUFFER_SIZE; i++) {
        int sample = adc1_get_raw(ADC1_CHANNEL_0);
        audioBuffer[i] = sample - 2048;
        
        while (micros() - startTime < i * (1000000 / SAMPLE_RATE)) {
            delayMicroseconds(100);
        }
    }
    
    Serial.println("Запись завершена");
    isRecording = false;
}

String prepareAudioChunkJson(int startIndex, int count) {
    DynamicJsonDocument doc(16384);
    JsonArray audio = doc.createNestedArray("audio");
    
    for (int i = startIndex; i < startIndex + count; i++) {
        audio.add(audioBuffer[i]);
    }
    
    doc["sample_rate"] = SAMPLE_RATE;
    doc["chunk_index"] = startIndex / CHUNK_SIZE;
    doc["total_chunks"] = BUFFER_SIZE / CHUNK_SIZE;
    
    String jsonData;
    serializeJson(doc, jsonData);
    return jsonData;
}

bool sendAudioToServer() {
    isProcessing = true;
    matrix.clear();
    matrix.dot(0, 2, 1); // Индикатор отправки
    matrix.update();
    
    bool success = true;
    
    for (int i = 0; i < BUFFER_SIZE; i += CHUNK_SIZE) {
        String chunkJson = prepareAudioChunkJson(i, CHUNK_SIZE);
        
        HTTPClient http;
        http.begin(client, serverUrl);
        http.addHeader("Content-Type", "application/json");
        http.setTimeout(apiTimeout);
        
        Serial.print("Отправка чанка ");
        Serial.print(i / CHUNK_SIZE + 1);
        Serial.print(" из ");
        Serial.println(BUFFER_SIZE / CHUNK_SIZE);
        
        int httpCode = http.POST(chunkJson);
        if (httpCode > 0) {
            String response = http.getString();
            if (i == BUFFER_SIZE - CHUNK_SIZE) { // Последний чанк
                DynamicJsonDocument doc(512);
                DeserializationError error = deserializeJson(doc, response);
                if (!error && doc.containsKey("command")) {
                    handleCommand(doc["command"].as<String>());
                }
            }
        } else {
            Serial.print("Ошибка HTTP: ");
            Serial.println(httpCode);
            success = false;
            break;
        }
        http.end();
    }
    
    isProcessing = false;
    return success;
}

void handleCommand(String command) {
    Serial.print("Получена команда: ");
    Serial.println(command);
    
    matrix.clear();
    if (command == "время") {
        matrix.dot(0, 0, 1);
    } else if (command == "дата") {
        matrix.dot(0, 1, 1);
    } else if (command == "алгоритмы") {
        matrix.dot(0, 2, 1);
    }
    matrix.update();
    delay(2000); // Показываем команду 2 секунды
}

void setup() {
    Serial.begin(115200);
    delay(1000);
    Serial.println("\nИнициализация системы...");
    
    // Настройка кнопки
    pinMode(BUTTON_PIN, INPUT_PULLUP);
    attachInterrupt(digitalPinToInterrupt(BUTTON_PIN), buttonISR, FALLING);
    
    // Настройка АЦП
    adc1_config_width(ADC_WIDTH_BIT_12);
    adc1_config_channel_atten(ADC1_CHANNEL_0, ADC_ATTEN_DB_12);
    
    // Настройка матрицы
    matrix.begin();
    matrix.setBright(5);
    matrix.clear();
    matrix.dot(5, 0, 1); // Индикатор готовности
    matrix.update();
    
    // Подключение к WiFi
    connectWiFi();
    
    Serial.println("Система готова к работе. Нажмите кнопку для записи.");
}

void loop() {
    if (buttonPressed && !isRecording && !isProcessing) {
        buttonPressed = false;
        
        // Проверка WiFi
        if (WiFi.status() != WL_CONNECTED) {
            connectWiFi();
            if (WiFi.status() != WL_CONNECTED) {
                matrix.clear();
                matrix.dot(5, 3, 1); // Индикатор ошибки WiFi
                matrix.update();
                delay(2000);
                return;
            }
        }
        
        // Запись аудио
        recordAudio();
        
        // Отправка на сервер
        if (!sendAudioToServer()) {
            matrix.clear();
            matrix.dot(5, 3, 1); // Индикатор ошибки
            matrix.update();
            delay(2000);
        }
        
        // Готов к новой записи
        matrix.clear();
        matrix.dot(5, 0, 1); // Индикатор готовности
        matrix.update();
    }
    
    delay(10);
}
